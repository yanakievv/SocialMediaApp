Index: app/src/main/java/com/example/socialmediaappv2/upload/Camera2Activity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>@file:Suppress(\"DEPRECATION\")\n\npackage com.example.socialmediaappv2.upload\n\nimport android.Manifest\nimport android.annotation.SuppressLint\nimport android.app.Activity\nimport android.content.ContentResolver\nimport android.content.ContentValues\nimport android.content.Context\nimport android.content.Intent\nimport android.content.pm.PackageManager\nimport android.graphics.*\nimport android.hardware.camera2.*\nimport android.hardware.camera2.CameraCaptureSession.CaptureCallback\nimport android.hardware.camera2.params.MeteringRectangle\nimport android.media.Image\nimport android.media.ImageReader\nimport android.media.MediaScannerConnection\nimport android.os.*\nimport android.provider.MediaStore.Images.Media\nimport android.util.Log\nimport android.util.Size\nimport android.util.SparseIntArray\nimport android.view.*\nimport android.view.TextureView.SurfaceTextureListener\nimport android.widget.Toast\nimport androidx.annotation.RequiresApi\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.core.app.ActivityCompat\nimport androidx.core.content.ContextCompat\nimport androidx.core.math.MathUtils\nimport com.example.socialmediaappv2.R\nimport com.example.socialmediaappv2.UserInfoPresenter\nimport com.example.socialmediaappv2.contract.Contract\nimport com.example.socialmediaappv2.data.SharedPreference\nimport com.example.socialmediaappv2.home.HomeActivity\nimport com.google.android.gms.location.FusedLocationProviderClient\nimport com.google.android.gms.location.LocationServices\nimport kotlinx.android.synthetic.main.activity_camera2.*\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\nimport java.io.File\nimport java.io.FileNotFoundException\nimport java.io.FileOutputStream\nimport java.io.IOException\nimport java.nio.ByteBuffer\nimport java.text.SimpleDateFormat\nimport java.util.*\nimport kotlin.collections.ArrayList\nimport kotlin.math.roundToInt\nimport kotlin.math.sqrt\nimport kotlin.random.Random.Default.nextDouble\n\n\nprivate const val REQUEST_CAMERA_PERMISSION = 200\nprivate const val GET_LAT_LONG = \"GETLATLONG\"\n\n\n\nclass Camera2Activity : AppCompatActivity(), Contract.MainView {\n\n    private val tag = \"AndroidCameraApi\"\n    private val orientations = SparseIntArray()\n\n    private lateinit var presenter: Contract.UserInfoPresenter\n    private lateinit var fusedLocationClient: FusedLocationProviderClient\n\n    private var cameraId: String? = null\n    private var cameraDevice: CameraDevice? = null\n    private var cameraCaptureSessions: CameraCaptureSession? = null\n    private var captureRequestBuilder: CaptureRequest.Builder? = null\n\n    private var imageDimension: Size? = null\n    private var imageReader: ImageReader? = null\n    private val file: File? = null\n\n    private var lat: Double = 0.0\n    private var long: Double = 0.0\n\n    private var mBackgroundHandler: Handler? = null\n    private var mBackgroundThread: HandlerThread? = null\n\n    private lateinit var sharedPref: SharedPreference\n\n    private var camera = 0 //0 is for back 1 is for front\n    private var flash: Boolean = false\n\n    var fingeSpacing = 0F\n    var zoomLevel = 1F\n\n    private class ImageSaver(val mImage: Image, val mFile: File, val angle: Float): Runnable {\n        override fun run() {\n            val buffer: ByteBuffer = mImage.planes[0].buffer\n            val bytes = ByteArray(buffer.remaining())\n            buffer.get(bytes)\n            var output: FileOutputStream? = null\n            try {\n                output = FileOutputStream(mFile)\n                output.write(bytes)\n            } catch (e: IOException) {\n                e.printStackTrace()\n            } finally {\n                mImage.close()\n                if (null != output) {\n                    try {\n                        output.close()\n                    } catch (e: IOException) {\n                        e.printStackTrace()\n                    }\n                }\n                rotateImage(mFile, angle)\n            }\n        }\n        private fun rotateImage(tempPhoto: File, angle: Float) {\n            val photoPath: String = tempPhoto.path.toString()\n            var bmp = BitmapFactory.decodeFile(photoPath)\n\n            val matrix = Matrix()\n            matrix.postRotate(angle)\n            bmp = Bitmap.createBitmap(bmp, 0, 0, bmp.width, bmp.height, matrix, true)\n\n            val fOut: FileOutputStream\n            try {\n                fOut = FileOutputStream(tempPhoto)\n                bmp.compress(Bitmap.CompressFormat.JPEG, 85, fOut)\n                fOut.flush()\n                fOut.close()\n            } catch (e1: FileNotFoundException) {\n                e1.printStackTrace()\n            } catch (e: IOException) {\n                e.printStackTrace()\n            }\n        }\n    }\n\n\n\n\n\n    @RequiresApi(Build.VERSION_CODES.M)\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        requestWindowFeature(Window.FEATURE_NO_TITLE)\n        window.setFlags(\n            WindowManager.LayoutParams.FLAG_FULLSCREEN,\n            WindowManager.LayoutParams.FLAG_FULLSCREEN\n        )\n        setContentView(R.layout.activity_camera2)\n\n        orientations.append(Surface.ROTATION_0, 90)\n        orientations.append(Surface.ROTATION_90, 0)\n        orientations.append(Surface.ROTATION_180, 270)\n        orientations.append(Surface.ROTATION_270, 180)\n\n        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this)\n        sharedPref = SharedPreference(this)\n        setPresenter(UserInfoPresenter(this))\n        CoroutineScope(Dispatchers.IO).launch { presenter.init(\n            sharedPref.getString(\"publisherId\")!!,\n            \"\",\n            this@Camera2Activity\n        )\n        }\n        textureView.surfaceTextureListener = textureListener\n        disableButtons()\n        takePictureButton.setOnClickListener { takePicture() }\n        backButton.setOnClickListener {\n            closeCamera()\n            startActivity(Intent(this, HomeActivity::class.java))\n        }\n        swapButton.setOnClickListener {\n            closeCamera()\n            openCamera(if (camera == 0) 1 else 0)\n            camera = if (camera == 0) 1 else 0\n            sharedPref.save(\"orientation\", camera)\n            updateFlashButton(camera == 0)\n        }\n        flashButton.setOnClickListener {\n            flash = !flash\n            updateFlashButton(true)\n            sharedPref.save(\"flash\", flash)\n        }\n        textureView.setOnTouchListener(object : View.OnTouchListener {\n            @SuppressLint(\"ClickableViewAccessibility\")\n            override fun onTouch(v: View?, event: MotionEvent): Boolean {\n                try {\n                    val activity: Activity = this@Camera2Activity\n                    val manager = activity.getSystemService(CAMERA_SERVICE) as CameraManager\n                    val characteristics = manager.getCameraCharacteristics(cameraId!!)\n                    val maxZoom =\n                        characteristics[CameraCharacteristics.SCALER_AVAILABLE_MAX_DIGITAL_ZOOM]!! //for LGE LM-G710 its 8.0\n                    val action: Int = event.action\n                    val currentFingerSpacing: Float\n                    if (event.pointerCount > 1) {\n                        currentFingerSpacing = getFingerSpacing(event)\n                        if (fingeSpacing != 0F) {\n                            if (currentFingerSpacing > fingeSpacing && maxZoom > zoomLevel) {\n                                zoomLevel += .05F\n                            } else if (currentFingerSpacing < fingeSpacing && zoomLevel > 1) {\n                                zoomLevel -= .05F\n                                if (zoomLevel < 1) zoomLevel = 1F\n                            }\n                            val matrix = Matrix()\n                            matrix.setScale(\n                                zoomLevel,\n                                zoomLevel,\n                                textureView.width / 2F,\n                                textureView.height / 2F\n                            )\n                            textureView.setTransform(matrix)\n                        }\n                        fingeSpacing = currentFingerSpacing\n                    } else {\n                        if (action == MotionEvent.ACTION_UP) {\n                            // end of tap\n                        }\n                    }\n                } catch (e: CameraAccessException) {\n                    throw RuntimeException(\"can not access camera.\", e)\n                }\n                return true\n            }\n        })\n    }\n\n    private fun calculateFocusRect(x: Float, y: Float): MeteringRectangle {\n        val areaSize = 50\n        val left: Int = clamp(x.toInt() - areaSize / 2, 0, textureView.width - areaSize)\n        val top: Int = clamp(y.toInt() - areaSize / 2, 0, textureView.height - areaSize)\n        val rectF = RectF(\n            left.toFloat(),\n            top.toFloat(),\n            (left + areaSize).toFloat(),\n            (top + areaSize).toFloat()\n        )\n        val focusRect = Rect(\n            rectF.left.roundToInt(),\n            rectF.top.roundToInt(), rectF.right.roundToInt(),\n            rectF.bottom.roundToInt()\n        )\n        return MeteringRectangle(focusRect, 1)\n    }\n\n    private fun clamp(x: Int, min: Int, max: Int): Int {\n        if (x > max) {\n            return max\n        }\n        return if (x < min) {\n            min\n        } else x\n    }\n\n    private var textureListener: SurfaceTextureListener = object : SurfaceTextureListener {\n\n        override fun onSurfaceTextureAvailable(surface: SurfaceTexture, width: Int, height: Int) {\n            openCamera(camera)\n        }\n\n        override fun onSurfaceTextureSizeChanged(surface: SurfaceTexture, width: Int, height: Int) {}\n\n        override fun onSurfaceTextureDestroyed(surface: SurfaceTexture): Boolean {\n            return false\n        }\n\n        override fun onSurfaceTextureUpdated(surface: SurfaceTexture) {}\n    }\n\n    private val stateCallback: CameraDevice.StateCallback = object : CameraDevice.StateCallback() {\n        override fun onOpened(camera: CameraDevice) {\n            Log.e(tag, \"onOpened\")\n            cameraDevice = camera\n            createCameraPreview()\n            enableButtons()\n        }\n\n        override fun onDisconnected(camera: CameraDevice) {\n            cameraDevice?.close()\n        }\n\n        override fun onError(camera: CameraDevice, error: Int) {\n            cameraDevice?.close()\n            cameraDevice = null\n        }\n    }\n\n    private fun startBackgroundThread() {\n        mBackgroundThread = HandlerThread(\"Camera Background\")\n        mBackgroundThread!!.start()\n        mBackgroundHandler = Handler(mBackgroundThread!!.looper)\n    }\n\n    private fun stopBackgroundThread() {\n        mBackgroundThread?.quitSafely()\n        try {\n            mBackgroundThread?.join()\n            mBackgroundThread = null\n            mBackgroundHandler = null\n        } catch (e: InterruptedException) {\n            e.printStackTrace()\n        }\n    }\n\n    @SuppressLint(\"MissingPermission\")\n    @RequiresApi(Build.VERSION_CODES.M)\n    private fun takePicture() {\n        disableButtons()\n        if (!getLatLong())\n        {\n            return\n        }\n        if (null == cameraDevice) {\n            Log.e(tag, \"cameraDevice null\")\n            return\n        }\n        val manager = getSystemService(Context.CAMERA_SERVICE) as CameraManager\n        try {\n            val characteristics = manager.getCameraCharacteristics(cameraDevice!!.id)\n            val jpegSizes: Array<Size>?\n            jpegSizes =\n                characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)!!\n                    .getOutputSizes(ImageFormat.JPEG)\n            var width = 640\n            var height = 480\n            if (jpegSizes != null && jpegSizes.isNotEmpty()) {\n                width = jpegSizes[0].width\n                height = jpegSizes[0].height\n            }\n            val reader: ImageReader = ImageReader.newInstance(width, height, ImageFormat.JPEG, 5)\n            val outputSurfaces: MutableList<Surface> = ArrayList(2)\n            outputSurfaces.add(reader.surface)\n            outputSurfaces.add(Surface(textureView.surfaceTexture))\n            val captureBuilder: CaptureRequest.Builder =\n                cameraDevice!!.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE) // *\n            captureBuilder.addTarget(reader.surface)\n            Zoom(characteristics).setZoom(captureBuilder, zoomLevel)\n            if (flash && camera == 0) captureBuilder.set(\n                CaptureRequest.FLASH_MODE,\n                CaptureRequest.FLASH_MODE_SINGLE\n            )\n            captureBuilder.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_MODE_AUTO)\n            // Orientation\n            @Suppress(\"DEPRECATION\") val rotation = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {\n                this.display?.rotation\n            } else {\n                windowManager.defaultDisplay.rotation\n            }\n            captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, orientations.get(rotation!!))\n            val readerListener: ImageReader.OnImageAvailableListener =\n                ImageReader.OnImageAvailableListener {\n                    SharedPreference.imagesTaken++\n                    val angle =\n                        if (camera == 1 && getRotation(this@Camera2Activity) == 0F) {\n                            270F + getRotation(this@Camera2Activity)\n                        }\n                        else {\n                            90F + getRotation(this@Camera2Activity)\n                        }\n                    val pathD = getExternalFilesDir(null)\n                        .toString() + \"/\" + Environment.DIRECTORY_DCIM + \"/\"\n                    val mediaStorageDir = File(pathD, \"MyAlbum\")\n                    if (!mediaStorageDir.exists()) {\n                        if (!mediaStorageDir.mkdirs()) {\n                            Log.d(\"MyCameraApp\", \"failed to create directory\")\n                        }\n                    }\n                    val timeStamp: String =\n                        SimpleDateFormat(\"yyyyMMdd_HHmmss\", Locale.getDefault()).format(Date())\n                    val mFile = File(mediaStorageDir, \"ImageName_$timeStamp.jpeg\")\n\n                    val values = ContentValues()\n                    values.put(Media.TITLE, \"ImageName\")\n                    //values.put(Media.CONTENT_TYPE, \"image/jpeg\")\n                    values.put(\"_data\", mFile.absolutePath)\n                    MediaScannerConnection.scanFile(\n                        applicationContext, arrayOf(file.toString()),\n                        arrayOf(mFile.name), null\n                    )\n\n                    val cr: ContentResolver = applicationContext.contentResolver\n                    cr.insert(Media.EXTERNAL_CONTENT_URI, values)\n                    mBackgroundHandler!!.post(ImageSaver(it.acquireNextImage(), mFile, angle))\n                    presenter.addPost(\n                        mFile.absolutePath,\n                        if (camera == 0) 1 + rotation else -1 - rotation,\n                        doubleArrayOf(\n                            lat,\n                            long\n                        ),\n                        this\n                    )\n                    sharedPref.save(\"lat\", lat.toString())\n                    sharedPref.save(\"long\", long.toString())\n                }\n            reader.setOnImageAvailableListener(readerListener, mBackgroundHandler)\n            val captureListener: CaptureCallback = object : CaptureCallback() {\n                override fun onCaptureCompleted(\n                    session: CameraCaptureSession,\n                    request: CaptureRequest,\n                    result: TotalCaptureResult\n                ) {\n                    super.onCaptureCompleted(session, request, result)\n                    createCameraPreview()\n                }\n            }\n            cameraDevice!!.createCaptureSession(\n                outputSurfaces,\n                object : CameraCaptureSession.StateCallback() {\n                    override fun onConfigured(session: CameraCaptureSession) {\n                        try {\n                            session.capture(\n                                captureBuilder.build(),\n                                captureListener,\n                                mBackgroundHandler\n                            )\n                        } catch (e: CameraAccessException) {\n                            e.printStackTrace()\n                        }\n                    }\n\n                    override fun onConfigureFailed(session: CameraCaptureSession) {}\n                },\n                mBackgroundHandler\n            )\n        } catch (e: CameraAccessException) {\n            e.printStackTrace()\n        }\n        enableButtons()\n    }\n\n    private fun createCameraPreview() {\n        try {\n            val texture: SurfaceTexture = textureView.surfaceTexture!!\n            texture.setDefaultBufferSize(imageDimension!!.width, imageDimension!!.height)\n            val surface = Surface(texture)\n            captureRequestBuilder = cameraDevice?.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW)\n            captureRequestBuilder!!.addTarget(surface)\n            cameraDevice?.createCaptureSession(\n                listOf(surface),\n                object : CameraCaptureSession.StateCallback() {\n                    override fun onConfigured(cameraCaptureSession: CameraCaptureSession) {\n                        if (null == cameraDevice) {\n                            return\n                        }\n                        cameraCaptureSessions = cameraCaptureSession\n                        updatePreview()\n                    }\n\n                    override fun onConfigureFailed(cameraCaptureSession: CameraCaptureSession) {\n                        Toast.makeText(\n                            this@Camera2Activity,\n                            \"Configuration change\",\n                            Toast.LENGTH_SHORT\n                        ).show()\n                    }\n                },\n                null\n            )\n        } catch (e: CameraAccessException) {\n            e.printStackTrace()\n        }\n    }\n\n    private fun openCamera(id: Int) {\n        val manager = getSystemService(Context.CAMERA_SERVICE) as CameraManager\n        Log.e(tag, \"is camera open\")\n        try {\n            cameraId = manager.cameraIdList[id]\n            val characteristics = manager.getCameraCharacteristics(cameraId as String)\n            val map = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)!!\n            imageDimension = map.getOutputSizes(SurfaceTexture::class.java)[0]\n            if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED || ActivityCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {\n                ActivityCompat.requestPermissions(\n                    this@Camera2Activity,\n                    arrayOf(Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE),\n                    REQUEST_CAMERA_PERMISSION\n                )\n                return\n            }\n            manager.openCamera(cameraId!!, stateCallback, null)\n        } catch (e: CameraAccessException) {\n            e.printStackTrace()\n        }\n        Log.e(tag, \"openCamera X\")\n    }\n\n    private fun updatePreview() {\n        if (null == cameraDevice) {\n            Log.e(tag, \"updatePreview error, return\")\n        }\n        captureRequestBuilder?.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_MODE_AUTO)\n        try {\n            cameraCaptureSessions?.setRepeatingRequest(\n                captureRequestBuilder!!.build(),\n                null,\n                mBackgroundHandler\n            )\n        } catch (e: CameraAccessException) {\n            e.printStackTrace()\n        }\n    }\n\n    private fun closeCamera() {\n        if (null != cameraDevice) {\n            cameraDevice!!.close()\n            cameraDevice = null\n        }\n        if (null != imageReader) {\n            imageReader!!.close()\n            imageReader = null\n        }\n    }\n\n    override fun onRequestPermissionsResult(\n        requestCode: Int,\n        permissions: Array<String?>,\n        grantResults: IntArray\n    ) {\n        if (requestCode == REQUEST_CAMERA_PERMISSION) {\n            if (grantResults[0] == PackageManager.PERMISSION_DENIED) {\n                // close the app\n                Toast.makeText(\n                    this@Camera2Activity,\n                    \"Cannot use app without granting proper camera permissions!\",\n                    Toast.LENGTH_LONG\n                ).show()\n                finish()\n            }\n        }\n    }\n\n    override fun onResume() {\n        super.onResume()\n        Log.e(tag, \"onResume\")\n        if (!this::presenter.isInitialized) {\n            CoroutineScope(Dispatchers.IO).launch { presenter.init(\n                sharedPref.getString(\"publisherId\")!!,\n                \"\",\n                this@Camera2Activity\n            )\n            }\n        }\n        sharedPref = SharedPreference(this)\n        camera = sharedPref.getInt(\"orientation\")\n        flash = sharedPref.getBoolean(\"flash\")\n        updateFlashButton(camera == 0)\n        startBackgroundThread()\n        if (textureView.isAvailable) {\n            openCamera(camera)\n        } else {\n            textureView.surfaceTextureListener = textureListener\n            textureView.rotation = getRotation(this@Camera2Activity)\n            //Toast.makeText(this@Camera2Activity, getRotation(this@Camera2Activity).toString(), Toast.LENGTH_SHORT).show()\n        }\n    }\n\n\n\n    override fun onPause() {\n        Log.e(tag, \"onPause\")\n        closeCamera()\n        stopBackgroundThread()\n        super.onPause()\n    }\n\n    override fun setPresenter(_presenter: Contract.UserInfoPresenter) {\n        presenter = _presenter\n    }\n\n    private fun disableButtons() {\n        takePictureButton.isEnabled = false\n        backButton.isEnabled = false\n    }\n\n    private fun enableButtons() {\n        takePictureButton.isEnabled = true\n        backButton.isEnabled = true\n    }\n\n    private fun getLatLong(): Boolean {\n        if (ActivityCompat.checkSelfPermission(\n                this,\n                Manifest.permission.ACCESS_FINE_LOCATION\n            ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(\n                this,\n                Manifest.permission.ACCESS_COARSE_LOCATION\n            ) != PackageManager.PERMISSION_GRANTED\n        ) {\n            Log.e(GET_LAT_LONG, \"Permissions not granted.\")\n            return false\n        }\n        fusedLocationClient.lastLocation.addOnSuccessListener {\n            if (it != null) {\n                lat = it.latitude\n                long = it.longitude\n                lat += nextDouble()*10\n                long += nextDouble()*10\n                Log.e(\n                    GET_LAT_LONG,\n                    \"Random coordinates created. Coordinates are: ${lat} ${long}.\"\n                )\n                Log.e(GET_LAT_LONG, \"Go to line 595 in Camera2Activity to use real coords.\")\n            }\n        }\n        return true\n    }\n\n    //Determine the space between the first two fingers\n    private fun getFingerSpacing(event: MotionEvent): Float {\n        val x: Float = event.getX(0) - event.getX(1)\n        val y: Float = event.getY(0) - event.getY(1)\n        return sqrt(x * x + y * y.toDouble()).toFloat()\n    }\n\n    private fun getRotation(context: Context): Float {\n        val rotation: Int =\n            (context.getSystemService(WINDOW_SERVICE) as WindowManager).defaultDisplay.orientation\n        return when (rotation) {\n            Surface.ROTATION_0 -> 0F\n            Surface.ROTATION_90 -> 270F\n            Surface.ROTATION_180 -> 180F\n            else -> 90F\n        }\n    }\n    private fun updateFlashButton(visible: Boolean) { //hide the flash button when using front facing camera\n        if (visible) {\n            flashButton.visibility = View.VISIBLE\n            if (flash) {\n                flashButton.setImageDrawable(\n                    ContextCompat.getDrawable(\n                        applicationContext,\n                        R.drawable.ic_baseline_flash_on_48\n                    )\n                )\n            } else {\n                flashButton.setImageDrawable(\n                    ContextCompat.getDrawable(\n                        applicationContext,\n                        R.drawable.ic_baseline_flash_off_48\n                    )\n                )\n            }\n        }\n        else flashButton.visibility = View.INVISIBLE\n    }\n}\nclass Zoom(characteristics: CameraCharacteristics) {\n    private val mCropRegion: Rect = Rect()\n    var maxZoom: Float\n\n    private val mSensorSize: Rect? = characteristics[CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE]\n    var hasSupport: Boolean\n    fun setZoom(builder: CaptureRequest.Builder, zoom: Float) {\n        if (!hasSupport) {\n            return\n        }\n        val newZoom: Float = MathUtils.clamp(\n            zoom, DEFAULT_ZOOM_FACTOR,\n            maxZoom\n        )\n        val centerX: Int = mSensorSize!!.width() / 2\n        val centerY: Int = mSensorSize.height() / 2\n        val deltaX = (0.5f * mSensorSize.width() / newZoom).toInt()\n        val deltaY = (0.5f * mSensorSize.height() / newZoom).toInt()\n        mCropRegion.set(\n            centerX - deltaX,\n            centerY - deltaY,\n            centerX + deltaX,\n            centerY + deltaY\n        )\n        builder.set(CaptureRequest.SCALER_CROP_REGION, mCropRegion)\n    }\n\n    companion object {\n        private const val DEFAULT_ZOOM_FACTOR = 1.0f\n    }\n\n    init {\n        if (mSensorSize == null) {\n            maxZoom = DEFAULT_ZOOM_FACTOR\n            hasSupport = false\n        }\n        val value = characteristics[CameraCharacteristics.SCALER_AVAILABLE_MAX_DIGITAL_ZOOM]\n        maxZoom = if (value == null || value < DEFAULT_ZOOM_FACTOR) DEFAULT_ZOOM_FACTOR else value\n        hasSupport = maxZoom.compareTo(DEFAULT_ZOOM_FACTOR) > 0\n    }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/socialmediaappv2/upload/Camera2Activity.kt	(revision f5cb8ba612d46963ad75fb3799e2501eb7625aa8)
+++ app/src/main/java/com/example/socialmediaappv2/upload/Camera2Activity.kt	(date 1607347576000)
@@ -41,6 +41,7 @@
 import kotlinx.coroutines.CoroutineScope
 import kotlinx.coroutines.Dispatchers
 import kotlinx.coroutines.launch
+import kotlinx.coroutines.runBlocking
 import java.io.File
 import java.io.FileNotFoundException
 import java.io.FileOutputStream
@@ -342,7 +343,7 @@
             captureBuilder.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_MODE_AUTO)
             // Orientation
             @Suppress("DEPRECATION") val rotation = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
-                this.display?.rotation
+                applicationContext.display?.rotation
             } else {
                 windowManager.defaultDisplay.rotation
             }
@@ -371,7 +372,7 @@
 
                     val values = ContentValues()
                     values.put(Media.TITLE, "ImageName")
-                    //values.put(Media.CONTENT_TYPE, "image/jpeg")
+                    values.put(Media.CONTENT_TYPE, "image/jpeg")
                     values.put("_data", mFile.absolutePath)
                     MediaScannerConnection.scanFile(
                         applicationContext, arrayOf(file.toString()),
@@ -592,10 +593,10 @@
         }
         fusedLocationClient.lastLocation.addOnSuccessListener {
             if (it != null) {
-                lat = it.latitude
-                long = it.longitude
-                lat += nextDouble()*10
-                long += nextDouble()*10
+                /*lat = it.latitude
+                long = it.longitude*/
+                lat = nextDouble()*100
+                long = nextDouble()*100
                 Log.e(
                     GET_LAT_LONG,
                     "Random coordinates created. Coordinates are: ${lat} ${long}."
Index: app/src/main/java/com/example/socialmediaappv2/login/LoginActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.socialmediaappv2.login\n\nimport android.Manifest\nimport android.annotation.SuppressLint\nimport android.content.Intent\nimport android.content.pm.PackageManager\nimport android.os.Bundle\nimport android.util.Log\nimport android.view.View\nimport android.widget.Toast\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.core.app.ActivityCompat\nimport androidx.core.content.ContextCompat\nimport com.example.socialmediaappv2.R\nimport com.example.socialmediaappv2.UserInfoPresenter\nimport com.example.socialmediaappv2.contract.Contract\nimport com.example.socialmediaappv2.data.SharedPreference\nimport com.example.socialmediaappv2.explore.content.PublicPictureContent\nimport com.example.socialmediaappv2.home.HomeActivity\nimport com.example.socialmediaappv2.home.content.PublisherPictureContent\nimport com.facebook.*\nimport com.facebook.AccessToken\nimport com.facebook.login.LoginManager\nimport com.facebook.login.LoginResult\nimport com.facebook.stetho.Stetho\nimport com.google.android.gms.auth.api.signin.GoogleSignIn\nimport com.google.android.gms.auth.api.signin.GoogleSignInAccount\nimport com.google.android.gms.auth.api.signin.GoogleSignInOptions\nimport com.google.android.gms.location.FusedLocationProviderClient\nimport com.google.android.gms.location.LocationServices\nimport kotlinx.android.synthetic.main.activity_login.*\n\n\nprivate const val RC_SIGN_IN = 7\nprivate const val GET_LAT_LONG = \"GETLATLONG\"\nprivate const val ACC_TAG = \"Logged as:\"\ninternal lateinit var presenter: Contract.UserInfoPresenter\nprivate lateinit var sharedPref: SharedPreference\ninternal lateinit var fusedLocationClient: FusedLocationProviderClient\n\nclass LoginActivity : AppCompatActivity(), Contract.MainView {\n\n    private lateinit var callbackManager: CallbackManager\n    private var publisherId: String? = null\n    private var publisherDisplayName: String? = null\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        FacebookSdk.sdkInitialize(applicationContext)\n        sharedPref = SharedPreference(this)\n        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this)\n        setContentView(R.layout.activity_login)\n        callbackManager = CallbackManager.Factory.create()\n        Stetho.initializeWithDefaults(this)\n        setPresenter(UserInfoPresenter(this))\n\n        //runBlocking{ UserDatabase.getInstance(applicationContext).imageDAO.nukeAll() }\n\n\n        val fbAccessToken: AccessToken? = AccessToken.getCurrentAccessToken()\n        val googleToken: GoogleSignInAccount? = GoogleSignIn.getLastSignedInAccount(this)\n\n        if (fbAccessToken != null && !fbAccessToken.isExpired) { //currently logged in with fb\n            updateUI(Profile.getCurrentProfile())\n        }\n        else if (googleToken != null) { // logged in with google\n            updateUI(googleToken)\n        }\n        else {\n            updateUI()\n        }\n\n        GLoginButton.setOnClickListener {\n            val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)\n                .requestIdToken(getString(R.string.default_web_client_id))\n                .requestEmail()\n                .build()\n            val mGoogleSignInClient = GoogleSignIn.getClient(this, gso)\n\n            if (GoogleSignIn.getLastSignedInAccount(this) == null) { // Google Login\n                val signInIntent = mGoogleSignInClient.signInIntent\n                startActivityForResult(signInIntent, RC_SIGN_IN)\n            } else { // Google Logout\n                mGoogleSignInClient.signOut()\n                updateUI()\n\n            }\n        }\n\n        FBMaskButton.setOnClickListener {\n            FBLoginButton.performClick()\n        }\n\n        FBLoginButton.setOnClickListener {\n            // Facebook Logout\n            if (AccessToken.getCurrentAccessToken() != null) {\n                GraphRequest(\n                    AccessToken.getCurrentAccessToken(), \"/me/permissions/\", null, HttpMethod.DELETE) {\n                    LoginManager.getInstance().logOut()\n                }.executeAsync()\n                updateUI()\n\n                // NOTE: When logging out a pop up window shows up to confirm log out but app stills logs out?\n                // After some research the fix I came up with is to modify the LoginButton.java in facebook-login-5.15.3-sources.jar so that the popup doesn't show.\n                // If building on your own machine the pop up will surely show so for a real experience I might upload the modified facebook package to github or you could modify it\n                // the .java file is located in com/facebook/login/widget, note that those directories are accessible after extracting the .jar file, source is called LoginButton.java\n                // go to line 796(should be in LoginClickListener scope) and modify the performLogout function to only declare a 'final LoginManager loginManager = getLoginManager();' and call 'loginManager.logOut();' right after that\n                // after modifying it compress the dirs com and META-INFO(or something like that) back to a .jar file with the same name as the original and voila.\n                // $ jar xvf [archive].jar\n                // $ jar cvf [dest].jar [file1 file2 ...]\n                // Really cheesy way to handle the popup, but I didn't find any way to remove it or do some kind of a listener/callback to see if clicked cancel or log out.\n\n            }\n            else {\n                // Facebook Login\n                FBLoginButton.setReadPermissions(\"email\", \"public_profile\")\n                LoginManager.getInstance().registerCallback(callbackManager,\n                    object : FacebookCallback<LoginResult> {\n                        private lateinit var profileTracker: ProfileTracker\n\n                        override fun onSuccess(loginResult: LoginResult?) {\n                            if (Profile.getCurrentProfile() == null) {\n                                profileTracker = object : ProfileTracker() {\n                                    override fun onCurrentProfileChanged(\n                                        oldProfile: Profile?,\n                                        currentProfile: Profile\n                                    ) {\n                                        Log.e(\n                                            ACC_TAG,\n                                            \"FB \" + currentProfile.firstName + \" \" + currentProfile.id\n                                        )\n                                        profileTracker.stopTracking()\n                                        updateUI(currentProfile)\n                                    }\n                                }\n\n                            } else {\n                                val profile = Profile.getCurrentProfile()\n                                Log.v(\"fbLogin\", profile.firstName)\n                            }\n                        }\n\n                        override fun onCancel() {\n                            Log.d(\"fbLogin\", \"onCancel.\")\n                        }\n\n                        override fun onError(error: FacebookException) {\n                            Log.d(\"fbLogin\", \"onError.\")\n                        }\n                    }\n                )\n            }\n        }\n\n        continueButton.setOnClickListener {\n            PublicPictureContent.nuke()\n            PublisherPictureContent.nuke()\n            sharedPref.clearData()\n            if (getLatLong()) {\n                presenter.init(publisherId!!, publisherDisplayName!!, applicationContext)\n                PublisherPictureContent.isCurrentUser = true\n                val intent = Intent(this, HomeActivity::class.java)\n                startActivity(intent)\n            }\n            else {\n                ActivityCompat.requestPermissions(\n                    this,\n                    arrayOf(Manifest.permission.ACCESS_FINE_LOCATION),\n                    1\n                )\n            }\n        }\n    }\n\n    @SuppressLint(\"SetTextI18n\")\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n        super.onActivityResult(requestCode, resultCode, data)\n        callbackManager.onActivityResult(requestCode, resultCode, data)\n\n        if (requestCode == RC_SIGN_IN && resultCode != 0) {\n            val account = GoogleSignIn.getLastSignedInAccount(this)\n            if (account != null) {\n                Log.e(ACC_TAG, \"Google \" + account.givenName + \" \" + account.id)\n                updateUI(account)\n            }\n        }\n    }\n\n    override fun onRequestPermissionsResult(\n        requestCode: Int,\n        permissions: Array<String>,\n        grantResults: IntArray\n    ) {\n        when (requestCode) {\n            1 -> {\n                if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED) {\n                    if ((ContextCompat.checkSelfPermission(\n                            this,\n                            Manifest.permission.ACCESS_FINE_LOCATION\n                        ) == PackageManager.PERMISSION_GRANTED)\n                    ) {\n                        continueButton.performClick()\n                    }\n                } else {\n                    Toast.makeText(\n                        this,\n                        \"Location service is used for determining what posts you see in the explore menu.\",\n                        Toast.LENGTH_SHORT\n                    ).show()\n                }\n                return\n            }\n        }\n    }\n\n    @SuppressLint(\"SetTextI18n\")\n    private fun updateUI(account: GoogleSignInAccount) { //Google\n        FBMaskButton.visibility = View.INVISIBLE\n        GLoginButton.text = \"Logout\"\n        continueButton.visibility = View.VISIBLE\n        greet.text = \"Hello, \" + account.givenName + \". Press the middle button below to continue.\"\n        publisherId = account.id\n        publisherDisplayName = account.displayName\n    }\n    @SuppressLint(\"SetTextI18n\")\n    private fun updateUI(account: Profile) { // Facebook\n        FBMaskButton.text = \"Logout\"\n        GLoginButton.visibility = View.INVISIBLE\n        continueButton.visibility = View.VISIBLE\n        greet.text = \"Hello, \" + account.firstName + \". Press the middle button below to continue.\"\n        publisherId = account.id\n        publisherDisplayName = account.firstName + \" \" + account.lastName\n\n    }\n    @SuppressLint(\"SetTextI18n\")\n    private fun updateUI() {\n        GLoginButton.text = \"Google\"\n        FBMaskButton.text = \"Facebook\"\n        continueButton.visibility = View.INVISIBLE\n        FBMaskButton.visibility = View.VISIBLE\n        GLoginButton.visibility = View.VISIBLE\n        greet.text = \"Log in to continue.\"\n    }\n\n    override fun setPresenter(_presenter: Contract.UserInfoPresenter) {\n        presenter = _presenter\n    }\n\n    private fun getLatLong(): Boolean {\n        if (ActivityCompat.checkSelfPermission(\n                this, Manifest.permission.ACCESS_FINE_LOCATION\n            ) != PackageManager.PERMISSION_GRANTED) {\n            return false\n        }\n        fusedLocationClient.lastLocation.addOnSuccessListener {\n            if (it != null) {\n                sharedPref.save(\"lat\", it.latitude.toString())\n                sharedPref.save(\"long\", it.longitude.toString())\n                Log.e(\n                    GET_LAT_LONG,\n                    \"Successful fetch. Coordinates are: ${sharedPref.getString(\"lat\")} ${\n                        sharedPref.getString(\n                            \"long\"\n                        )\n                    }.\"\n                )\n            }\n        }\n        return true\n    }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/com/example/socialmediaappv2/login/LoginActivity.kt	(revision f5cb8ba612d46963ad75fb3799e2501eb7625aa8)
+++ app/src/main/java/com/example/socialmediaappv2/login/LoginActivity.kt	(date 1607347576000)
@@ -29,6 +29,10 @@
 import com.google.android.gms.location.FusedLocationProviderClient
 import com.google.android.gms.location.LocationServices
 import kotlinx.android.synthetic.main.activity_login.*
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.runBlocking
 
 
 private const val RC_SIGN_IN = 7
